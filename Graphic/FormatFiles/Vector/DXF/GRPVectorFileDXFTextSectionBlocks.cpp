/**-------------------------------------------------------------------------------------------------------------------
* 
* @file       GRPVectorFileDXFTextSectionBlocks.cpp
* 
* @class      GRPVECTORFILEDXFTEXTSECTIONBLOCKS
* @brief      Graphic Vector File DXF Text Section Blocks class
* @ingroup    GRAPHIC
* 
* @copyright  EndoraSoft. All rights reserved.
* 
* @cond
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
* documentation files(the "Software"), to deal in the Software without restriction, including without limitation
* the rights to use, copy, modify, merge, publish, distribute, sublicense, and/ or sell copies of the Software,
* and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in all copies or substantial portions of
* the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
* THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
* @endcond
* 
* --------------------------------------------------------------------------------------------------------------------*/

/*---- PRECOMPILATION INCLUDES ---------------------------------------------------------------------------------------*/
#pragma region PRECOMPILATION_DEFINES_INCLUDE

#include "GEN_Defines.h"

#pragma endregion


/*---- INCLUDES ------------------------------------------------------------------------------------------------------*/
#pragma region INCLUDES

#include "GRPVectorFileDXFTextSectionBlocks.h"

#include "XMap.h"
#include "XVariant.h"

#include "GRPVectorFile_XEvent.h"
#include "GRPVectorFileDXF.h"
#include "GRPVectorFileDXFValue.h"
#include "GRPVectorFileDXFXDataCtrl.h"
#include "GRPVECTORFILEDXFTEXTBLOCK.h"
#include "GRPVectorFileDXFTextSectionEntities.h"

#pragma endregion


/*---- PRECOMPILATION INCLUDES ---------------------------------------------------------------------------------------*/
#pragma region PRECOMPILATION_CONTROL_INCLUDE

#include "GEN_Control.h"

#pragma endregion



/*---- GENERAL VARIABLE ----------------------------------------------------------------------------------------------*/
#pragma region GENERAL_VARIABLE


GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF GRPVECTORFILEDXFTEXTSECTIONBLOCKS::defBlock[GRPVECTORFILEDXFBLOCKS_MAXNDEFBLOCKS] = 
{    
  { __L("BLOCK")    , 15 , false,   { {   5 , __L("HANDLE")                     , __L("Handle") },
                                      { 102 , __L("XDATAGROUP1")                , __L("Start of application-defined group '{application_name'. For example, '{ACAD_REACTORS' indicates the start of the AutoCAD persistent reactors group (optional) application-defined codes Codes and values within the 102 groups are application defined (optional)") },
                                      { 102 , __L("XDATAGROUP2")                , __L("End of group, '}' (optional)") },
                                      { 330 , __L("ID-HDL_OWNER_OBJECT")        , __L("Soft-pointer ID/handle to owner object") },
                                      { 100 , __L("SUBCLASS_ACDBENTITY")        , __L("Subclass marker (AcDbBlock)") },
                                      {   8 , __L("LAYER_NAME")                 , __L("Layer name") },
                                      { 100 , __L("SUBCLASS_ACDBBLOCKBEGIN")    , __L("Subclass marker (AcDbBlockBegin)") },
                                      {   2 , __L("BLOCK_NAME")                 , __L("Block name") },
                                      {  70 , __L("BLOCK-TYPE_FLAGS")           , __L("Block-type flags (bit-coded values, may be combined): 0 = Indicates none of the following flags apply, 1 = This is an anonymous block generated by hatching, associative dimensioning, other internal operations, or an application, 2 = This block has non-constant attribute definitions (this bit is not set if the block has any attribute definitions that are constant, or has no attribute definitions at all), 4 = This block is an external reference (xref), 8 = This block is an xref overlay, 16 = This block is externally dependent, 32 = This is a resolved external reference, or dependent of an external reference (ignored on input), 64 = This definition is a referenced external reference (ignored on input).") },
                                      {  10 , __L("BASE_POINT_X")               , __L("Base point DXF: X value; APP: 3D point") },
                                      {  20 , __L("BASE_POINT_Y")               , __L("DXF: Y value of base point") },
                                      {  30 , __L("BASE_POINT_Z")               , __L("DXF: Z value of base point") },
                                      {   3 , __L("BLOCK_NAME")                 , __L("Block name") },
                                      {   1 , __L("XREF_PATH_NAME")             , __L("Xref path name") },
                                      {   4 , __L("BLOCK_DESCRIPTION")          , __L("Block description (optional)") } } },

  { __L("ENDBLK")   ,  1 ,  true,   { {   5 , __L("HANDLE")                     , __L("Handle") },
                                      { 102 , __L("XDATAGROUP")                 , __L("Start of application-defined group '{application_name'. For example, '{ACAD_REACTORS' indicates the start of the AutoCAD persistent reactors group (optional) application-defined codes Codes and values within the 102 groups are application defined (optional)") },
                                      { 102 , __L("END_GROUP")                  , __L("End of group, '}' (optional)") },
                                      { 330 , __L("ID-HDL_OWNER_OBJECT")        , __L("Soft-pointer ID/handle to owner object") },
                                      { 100 , __L("SUBCLASS_ACDBENTITY")        , __L("Subclass marker (AcDbBlock)") },
                                      {   8 , __L("LAYER_NAME")                 , __L("Layer name") },
                                      { 100 , __L("SUBCLASS_ACDBBLOCKEND")      , __L("Subclass marker (AcDbBlockEnd)") } } },   
};


#pragma endregion


/*---- CLASS MEMBERS -------------------------------------------------------------------------------------------------*/
#pragma region CLASS_MEMBERS


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         GRPVECTORFILEDXFTEXTSECTIONBLOCKS::GRPVECTORFILEDXFTEXTSECTIONBLOCKS()
* @brief      Constructor of class
* @ingroup    GRAPHIC
* 
* --------------------------------------------------------------------------------------------------------------------*/
GRPVECTORFILEDXFTEXTSECTIONBLOCKS::GRPVECTORFILEDXFTEXTSECTIONBLOCKS()
{
  Clean();

  type = GRPVECTORFILEDXFTEXTSECTION_TYPESECTION_BLOCKS;
}


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         GRPVECTORFILEDXFTEXTSECTIONBLOCKS::~GRPVECTORFILEDXFTEXTSECTIONBLOCKS()
* @brief      Destructor of class
* @note       VIRTUAL
* @ingroup    GRAPHIC
* 
* --------------------------------------------------------------------------------------------------------------------*/
GRPVECTORFILEDXFTEXTSECTIONBLOCKS::~GRPVECTORFILEDXFTEXTSECTIONBLOCKS()
{
  DeleteAllBlocks();

  Clean();
}


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::IsKnownBlock(XSTRING& name)
* @brief      Is known block
* @ingroup    GRAPHIC
* 
* @param[in]  name : 
* 
* @return     GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF* : 
* 
* --------------------------------------------------------------------------------------------------------------------*/
GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::IsKnownBlock(XSTRING& name)
{  
  for(XDWORD c=0; c<GRPVECTORFILEDXFBLOCKS_MAXNDEFBLOCKS; c++)
    {
      GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF* blockDef = &GRPVECTORFILEDXFTEXTSECTIONBLOCKS::defBlock[c];
      if(blockDef)
        {
          if(!name.Compare(blockDef->name, true)) 
            {
              return blockDef;
            }    
        }
    }
  
  return NULL;
}


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         GRPVECTORFILEDXFTEXTSECTIONBLOCKDEFTYPE* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::IsKnownTypeValue(XSTRING& namevar, int type)
* @brief      Is known type value
* @ingroup    GRAPHIC
* 
* @param[in]  namevar : 
* @param[in]  type : 
* 
* @return     GRPVECTORFILEDXFTEXTSECTIONBLOCKDEFTYPE* : 
* 
* --------------------------------------------------------------------------------------------------------------------*/
GRPVECTORFILEDXFTEXTSECTIONBLOCKDEFTYPE* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::IsKnownTypeValue(XSTRING& namevar, int type)
{  
  for(int c=0; c<GRPVECTORFILEDXFBLOCKS_MAXNDEFBLOCKS; c++)
    {
      GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF* block  = &GRPVECTORFILEDXFTEXTSECTIONBLOCKS::defBlock[c];
      if(block)
        {
          if(!namevar.Compare(block->name, true)) 
            {
              for(int d=0; d<block->ntypes; d++)
                {
                  GRPVECTORFILEDXFTEXTSECTIONBLOCKDEFTYPE* typeDef = &block->type[d]; 
                  if(typeDef)
                    {
                      if(typeDef->type == type) 
                        {
                          return typeDef;                  
                        }
                    }            
                }
            }    
        }
    }
  
  return NULL;
}


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::AddBlock(GRPVECTORFILEDXFTEXTBLOCK* block)
* @brief      Add block
* @ingroup    GRAPHIC
* 
* @param[in]  block : 
* 
* @return     bool : true if is succesful. 
* 
* --------------------------------------------------------------------------------------------------------------------*/
bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::AddBlock(GRPVECTORFILEDXFTEXTBLOCK* block)
{
  if(!block) 
    {
      return false;
    }

  if(block->GetName()->IsEmpty()) 
    {
      return false;
    }
  
  return blocks.Add(block); 
}


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         XVECTOR<GRPVECTORFILEDXFTEXTBLOCK*>* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::GetBlocks()
* @brief      Get blocks
* @ingroup    GRAPHIC
* 
* @return     XVECTOR<GRPVECTORFILEDXFTEXTBLOCK*>* : 
* 
* --------------------------------------------------------------------------------------------------------------------*/
XVECTOR<GRPVECTORFILEDXFTEXTBLOCK*>* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::GetBlocks()
{
  return &blocks;
}
    
    
/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         GRPVECTORFILEDXFTEXTBLOCK* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::GetBlock(XCHAR* nameblock, XDWORD index)
* @brief      Get block
* @ingroup    GRAPHIC
* 
* @param[in]  nameblock : 
* @param[in]  index : 
* 
* @return     GRPVECTORFILEDXFTEXTBLOCK* : 
* 
* --------------------------------------------------------------------------------------------------------------------*/
GRPVECTORFILEDXFTEXTBLOCK* GRPVECTORFILEDXFTEXTSECTIONBLOCKS::GetBlock(XCHAR* nameblock, XDWORD index)
{
  if(blocks.IsEmpty()) 
    {
      return NULL;
    }

  int iindex = 0;

  for(XDWORD c=0; c<blocks.GetSize(); c++)
    {
      GRPVECTORFILEDXFTEXTBLOCK* block = blocks.Get(c);
      if(block)
        {
          if(block->GetName()->Find(nameblock, false) != XSTRING_NOTFOUND)
            {
              if(iindex == index)
                {              
                  return block;
                }

              iindex ++;
            }
        }    
    }
  
  return NULL;
}
    
    
/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::DeleteBlock(XCHAR* nameblock, XDWORD index)
* @brief      Delete block
* @ingroup    GRAPHIC
* 
* @param[in]  nameblock : 
* @param[in]  index : 
* 
* @return     bool : true if is succesful. 
* 
* --------------------------------------------------------------------------------------------------------------------*/
bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::DeleteBlock(XCHAR* nameblock, XDWORD index)
{
  if(blocks.IsEmpty()) 
    {
      return false;
    }

  GRPVECTORFILEDXFTEXTBLOCK* block = GetBlock (nameblock, index);
  if(block)
    { 
      blocks.Delete(block);
      delete block;

      return true;
    }

  return false;    
}
    
    
/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::DeleteAllBlocks(XCHAR* nameblock)
* @brief      Delete all blocks
* @ingroup    GRAPHIC
* 
* @param[in]  nameblock : 
* 
* @return     bool : true if is succesful. 
* 
* --------------------------------------------------------------------------------------------------------------------*/
bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::DeleteAllBlocks(XCHAR* nameblock)
{
  if(blocks.IsEmpty()) 
    {
      return false;
    }

  GRPVECTORFILEDXFTEXTBLOCK*  block;
  int                         index = 0;

  do{ block = GetBlock (nameblock, index);
      if(block)
        {
          DeleteBlock(nameblock, index);
        }
       else 
        {
          index++;
        }
   
    } while(block);

  return true;
}
    
    
/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::DeleteAllBlocks()
* @brief      Delete all blocks
* @ingroup    GRAPHIC
* 
* @return     bool : true if is succesful. 
* 
* --------------------------------------------------------------------------------------------------------------------*/
bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::DeleteAllBlocks()
{
  if(blocks.IsEmpty()) 
    {
      return false;
    }

  blocks.DeleteContents();
  blocks.DeleteAll();

  return true;
}


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         GRPVECTORFILERESULT GRPVECTORFILEDXFTEXTSECTIONBLOCKS::ParserTextSection(XFILETXT* fileTXT)
* @brief      Parser text section
* @ingroup    GRAPHIC
* 
* @param[in]  fileTXT : 
* 
* @return     GRPVECTORFILERESULT : 
* 
* --------------------------------------------------------------------------------------------------------------------*/
GRPVECTORFILERESULT GRPVECTORFILEDXFTEXTSECTIONBLOCKS::ParserTextSection(XFILETXT* fileTXT)
{    
  XVECTOR<GRPVECTORFILEDXFTEXTPART*>  parts;
  GRPVECTORFILEDXFTEXTPART*           part      = NULL;  
  GRPVECTORFILEDXFXDATACTRL*          xdatactrl = NULL;
  int                                 indexline = iniline;
  XSTRING*                            line;
  
  part = new GRPVECTORFILEDXFTEXTPART();

  do{ line = fileTXT->GetLine(indexline);
      if(line) 
        {                       
          GRPVECTORFILEDXF::ParserTextFilePrepareLine(line);

          if(line && !line->Compare(__L("0"),true))
            {               
              line = fileTXT->GetLine(indexline + 1);
              GRPVECTORFILEDXF::ParserTextFilePrepareLine(line);

              if(IsKnownBlock(*line))
                {
                  indexline++; 
               
                  if(part)
                    {
                      if(part->iniline != -1)
                        {               
                          part->endline = indexline - 2; 
                                
                          parts.Add(part); 
                          part = NULL;
                  
                          part = new GRPVECTORFILEDXFTEXTPART ();
                        }
                       else
                        {
                          if(part->iniline == -1)
                            {                     
                              part->name    = line->Get();
                              part->iniline = indexline + 1;              
                            }                             
                        }
                    }
                }          
            } 
        }
                           
      indexline++;

    } while(indexline < endline);

  if(part && (part->iniline != -1))
    {               
      part->endline = indexline-1; 
      
      parts.Add(part); 
      part = NULL;           
    }

  if(part && part->iniline == -1)
    {
      delete part;
      part = NULL;    
    }
  
  for(XDWORD c=0; c<parts.GetSize(); c++)
    {
      part = parts.Get(c);
      if(part)
        {         
          GRPVECTORFILEDXFTEXTBLOCK* block = new GRPVECTORFILEDXFTEXTBLOCK();
          if(block)
            {               
              GRPVECTORFILEDXFTEXTSECTIONBLOCKDEF* blockDef = IsKnownBlock(part->name);
              if(blockDef)
                {
                  block->SetIsEndBlock(blockDef->isendblock);

                  if(blockDef->isendblock)
                    {
                      GRPVECTORFILEDXFTEXTBLOCK* lastblock = blocks.Get(blocks.GetSize()-1);
                      if(lastblock)
                        {
                          block->GetName()->Set(lastblock->GetName()->Get());
                        }                             
                    }
                }

              indexline = part->iniline;

              bool nomorevalues = false;
                  
              while(part->endline > indexline)
                {  
                  line = fileTXT->GetLine(indexline);      
                  if(line) 
                    {  
                      indexline++;                    

                      GRPVECTORFILEDXF::ParserTextFilePrepareLine(line);                  

                      int type = line->ConvertToInt();
                        
                      if(!type)
                        {                        
                          line = fileTXT->GetLine(indexline);
                          if(line)
                            {  
                              GRPVECTORFILEDXF::ParserTextFilePrepareLine(line); 
                                                     
                              GRPVECTORFILEDXFTEXTSECTIONENTITIES* sectionEntities = new GRPVECTORFILEDXFTEXTSECTIONENTITIES();
                              if(sectionEntities)
                                { 
                                  sectionEntities->iniline = indexline - 1;
                                  sectionEntities->endline = part->endline;

                                  if(sectionEntities->IsKnownEntity((*line)))
                                    {     
                                      sectionEntities->SetGrpVectorFile(GetGrpVectorFile());
                                      sectionEntities->ParserTextSection(fileTXT);  
                                      indexline = part->endline - 1;
                                 
                                      block->SetSectionEntities(sectionEntities);

                                      nomorevalues = true;
                                    }
                                }                                                                                                   
                            }                        
                        }

                      if(!nomorevalues)    
                        {
                          GRPVECTORFILEDXFVALUE* value = new GRPVECTORFILEDXFVALUE();
                          if(value)
                            {      
                              GRPVECTORFILEDXFTEXTSECTIONBLOCKDEFTYPE* defType = IsKnownTypeValue(part->name, type);
                              if(!defType)
                                {                              
                                  #ifdef TEST_ONLY_DEFINE_IN_BLOCKS

                                  XSTRING message;

                                  message.Format(__L("type data of block %d Not register [%d]"), type);
                               
                                  GRPVECTORFILE_XEVENT vfevent(GetGrpVectorFile(), GRPVECTORFILE_XEVENTTYPE_PartUnknown);

                                  vfevent.SetType(GRPVECTORFILETYPE_DXF);
                                  vfevent.GetPath()->Set(fileTXT->GetPrimaryFile()->GetPathnamefile());
                                  vfevent.GetMessage()->Set(message);

                                  PostEvent(&vfevent, GetGrpVectorFile());                           

                                  indexline++;                          
                                  delete value;
                           
                                  continue;

                                  #else

                                  GRPVECTORFILEDXFTEXTSECTIONGENERICDEFTYPE* genDefType = GetGenericDefType(type);
                                  if(genDefType)
                                    {
                                      value->SetType(genDefType->type);
                                      value->GetName()->Set(genDefType->name);
                                      value->GetRemark()->Set(genDefType->remark);                      
                                    }
                                   else 
                                    {                              
                                      XSTRING message;

                                      message.Format(__L("type data of block %d Not register [%d]"), type);
                               
                                      GRPVECTORFILE_XEVENT vfevent(GetGrpVectorFile(), GRPVECTORFILE_XEVENTTYPE_PARTUNKNOWN);

                                      vfevent.SetType(GRPVECTORFILETYPE_DXF);
                                      vfevent.GetPath()->Set(fileTXT->GetPrimaryFile()->GetPathNameFile());
                                      vfevent.GetMsg()->Set(message);

                                      PostEvent(&vfevent, GetGrpVectorFile());                          

                                      indexline++;
                                      continue;
                                    }

                                  #endif
                                }
                               else
                                {
                                  value->SetType(defType->type);
                                  value->GetName()->Set(defType->name);
                                  value->GetRemark()->Set(defType->remark); 
                                }

                              line = fileTXT->GetLine(indexline);
                              if(line)
                                {
                                  GRPVECTORFILEDXF::ParserTextFilePrepareLine(line); 
                           
                                  GetVariableFromLine(value->GetName()->Get(), type, line, (*value->GetData()));                        

                                  switch(IsXDataControl(type, (*line)))
                                    {
                                      case GRPVECTORFILEDXFTEXTSECTION_XDATACTRL_STATUS_NOT    :  if(xdatactrl) 
                                                                                                    {
                                                                                                      if(value) 
                                                                                                        {                                                                                                            
                                                                                                          xdatactrl->GetValues()->Add(value);   
                                                                                                        } 
                                                                                                    }
                                                                                                  break;

                                      case GRPVECTORFILEDXFTEXTSECTION_XDATACTRL_STATUS_INI    :  if(!xdatactrl)                
                                                                                                    {
                                                                                                      xdatactrl = new GRPVECTORFILEDXFXDATACTRL();
                                                                                                      if(xdatactrl)                
                                                                                                        {
                                                                                                           XSTRING name;
                                                                                                           line->Copy(1, name);
                                                                                       
                                                                                                           xdatactrl->GetName()->Set(name);
                                                                                                        }
                                                                                                     }
                                                                                                   break;

                                      case GRPVECTORFILEDXFTEXTSECTION_XDATACTRL_STATUS_END     :  if(xdatactrl)                
                                                                                                     { 
                                                                                                        block->GetXDataCtrlList()->Add(xdatactrl);
                                                                                                        xdatactrl = NULL;
                                                                                                     }                              
                                                                                                     break;
                                    }
 
                           
                                  if(value) 
                                    {  
                                      if((value->GetType() == 2) || (value->GetType() == 3))
                                        {
                                          XSTRING* data = (XSTRING*)(value->GetData()->GetData());                                 
                                          if(data) block->GetName()->Set(data->Get()); 
                                        }

                                      block->AddValue(value);
                                    }
                                }                                            
                            }
                        }
                    }
         
                  indexline++;

                }         

              AddBlock(block);
            }
        }
    } 

  parts.DeleteContents();
  parts.DeleteAll();

  #ifdef XTRACE_ACTIVE
  //ShowTraceAllBlocks();
  #endif
   
  return GRPVECTORFILERESULT_OK;
}


#ifdef XTRACE_ACTIVE
/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::ShowTraceAllBlocks()
* @brief      Show trace all blocks
* @ingroup    GRAPHIC
* 
* @return     bool : true if is succesful. 
* 
* --------------------------------------------------------------------------------------------------------------------*/
bool GRPVECTORFILEDXFTEXTSECTIONBLOCKS::ShowTraceAllBlocks()
{ 
  for(XDWORD c=0; c<blocks.GetSize(); c++)
    {
      GRPVECTORFILEDXFTEXTBLOCK* block = blocks.Get(c);
      if(block)
        {
          XTRACE_PRINTCOLOR(XTRACE_COLOR_BLUE, __L("[GRPVECTORFILEDXFTEXTSECTIONBLOCKS] (%3d) Block %c [%s] (%d) values."), c, (block->IsEndBlock()?__C('<'):__C('>')), block->GetName()->Get(), block->GetValues()->GetSize());
        }
    }

  return true;
}
#endif


/**-------------------------------------------------------------------------------------------------------------------
* 
* @fn         void GRPVECTORFILEDXFTEXTSECTIONBLOCKS::Clean()
* @brief      Clean the attributes of the class: Default initialize
* @note       INTERNAL
* @ingroup    GRAPHIC
* 
* --------------------------------------------------------------------------------------------------------------------*/
void GRPVECTORFILEDXFTEXTSECTIONBLOCKS::Clean()
{
  
}


#pragma endregion

